[{"title":"Vue学习笔记","date":"2017-01-03T15:53:19.000Z","path":"2017/01/03/learning-vue/","text":"介绍 Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。 Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 组件思想：将界面元素抽象为一个独立可复用的小组件，父组件包含若干个子组件，用这些组件构建大型的应用，因此任何一个应用界面都可以抽象为组件树。 组件思想 每个Vue实例在被创建之前都要经过一系列的初始化过程，例如，实例需要配置数据观测、编译模版、挂载实例到DOM、数据变化时更新DOM等，在实例的生命周期的不同阶段会调用不同的回调函数，用户可以在这些回调函数中定义自己的程序处理逻辑。 生命周期图示： 生命周期 安装直接下载直接下载并在html中用script应用，Vue会被注册为一个全局变量。开发版本 包含了完整的警告和调试模式生成版本 删除警告 NPM通过npm安装最新稳定版本$ npm install vue 命令行工具vue.js提供官方的命令行工具，可以快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。123456789101112# 全局安装 vue-cli$ npm install -g vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 安装依赖，走你$ cd my-project$ npm install$ npm run dev# 其他命令# 可以查看官方提供的模版， 如webpack-simple、bowserify、week等$ vue list 有前端基础的推荐使用命令行工具，它能够方便初学者快速构建各种框架工程，免去自己去查找资料的麻烦 简单使用插值数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：&lt;span&gt;Message: { {msg}}&lt;/span&gt; 计算属性计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 message 没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。1234567891011121314151617&lt;div id=&quot;example&quot;&gt; &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt; &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;&lt;/div&gt;var vm = new Vue(&#123; el: &apos;#example&apos;, data: &#123; message: &apos;Hello&apos; &#125;, computed: &#123; // a computed getter reversedMessage: function () &#123; // `this` points to the vm instance return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;) &#125; &#125;&#125;) 指令绑定属性一些指令能接受一个“参数”，在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; Class与Style绑定数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用v-bind 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 v-bind 用于 class 和 style 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。12345678910111213141516171819202122&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;//直接绑定数据里的一个对象&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;data: &#123; classObject: &#123; active: true, &apos;text-danger&apos;: false &#125;&#125;//可以把一个数组传给 v-bind:class&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;//用在组件上//当你在一个定制的组件上用到 class 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖Vue.component(&apos;my-component&apos;, &#123; template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;&#125;)&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;//HTML 最终将被渲染成为:&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt; v-bind:style 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。12345678910111213141516//CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;//直接绑定到一个样式对象通常更好，让模板更清晰&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;data: &#123; styleObject: &#123; color: &apos;red&apos;, fontSize: &apos;13px&apos; &#125;&#125;//v-bind:style 的数组语法可以将多个样式对象应用到一个元素上&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;//当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀 条件渲染单个语句&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;多条语句时，我们可以把一个 &lt;template&gt; 元素当做包装元素，并在上面使用 v-if，最终的渲染结果不会包含它。 12345&lt;template v-if=&quot;ok&quot;&gt; &lt;h1&gt;Title&lt;/h1&gt; &lt;p&gt;Paragraph 1&lt;/p&gt; &lt;p&gt;Paragraph 2&lt;/p&gt;&lt;/template&gt; if-else 123&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;&lt;div v-else&gt;C&lt;/div&gt; 另一个根据条件展示元素的选项是 v-show 指令。不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display 。注意 v-show 不支持 &lt;template&gt; 语法。&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt; v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。 列表渲染v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。123456&lt;ul&gt; &lt;template v-for=&quot;item in items&quot;&gt; &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt; &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 可以用 v-for 通过一个对象的属性来迭代123456789&lt;ul id=&quot;repeat-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;或&lt;div v-for=&quot;(value, key, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;&lt;/div&gt; v-for 也可以取整数。在这种情况下，它将重复多次模板:123&lt;div&gt; &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;&lt;/div&gt; 你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;组件中使用v-for：12345&lt;my-component v-for=&quot;(item, index) in items&quot; v-bind:item=&quot;item&quot; v-bind:index=&quot;index&quot;&gt;&lt;/my-component&gt; 监听事件v-on 指令，它用于监听 DOM 事件：1234&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt; 监听事件可以用修饰符指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;其他修饰符：1234567891011121314151617.stop.prevent.capture.self.once&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; 按键修饰符12345678910111213.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13=&quot;submit&quot;&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter=&quot;submit&quot;&gt; 可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应:12345678.ctrl.alt.shift.meta&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67=&quot;clear&quot;&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt; 双向数据绑定v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。文本12&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt; 单选1234567&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;&lt;br&gt;&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;&lt;br&gt;&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt; 选择列表123456&lt;select v-model=&quot;selected&quot;&gt; &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt; &#123;&#123; option.text &#125;&#125; &lt;/option&gt;&lt;/select&gt;&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt; 修饰符12345678&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;&lt;input v-model.lazy=&quot;msg&quot; &gt;//如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;//自动过滤用户输入的首尾空格&lt;input v-model.trim=&quot;msg&quot;&gt; 总结 官网基础教程讲解比较详细，从介绍-&gt;安装-&gt;实际例子都比较容易懂，不知道是否因为该库是华人开发的原因文档也由华人编写？ 通过这次的学习可以发现Vue吸取了AngularJS(双向数据绑定、模版、指令)和React（组件、父子组件单向数据流、虚拟DOM）的思想，并融合成一种更适合开发者开发的框架。另外，该框架提供了大量方便开发的方法，如修饰符、过滤器等，免去了查找库或插件的麻烦(如React需要安装各种工具)，可以说Vue是从开发者角度去考虑的框架，开发者使用起来变得更加顺心。正因如此，我也开始对Vue产生兴趣了。 参考Vue官网教程","tags":[{"name":"教程","slug":"教程","permalink":"http://www.leozeda.com/tags/教程/"},{"name":"Vue","slug":"Vue","permalink":"http://www.leozeda.com/tags/Vue/"}]},{"title":"资源收集","date":"2017-01-01T14:13:15.000Z","path":"2017/01/01/resource-collection/","text":"工具库 FullPage 非常好用的全屏滑动库, 有挺多Example Hexo Markdown生成静态页面，可做博客 hexo-theme-material Material主题的样式，作者非常用心，挺好看的主题，教程完整 hexo-theme-next NexT主题样式，比较经典，教程齐全 lib-flexible 阿里移动端多分辨率的兼容方案(rem) TinyPng 图片批量压缩脚本(Python) Swiper 针对移动端触摸屏的滑屏插件，兼容iOS，Android，WP8和桌面浏览器 CreateJs H5制作动画的库 React-dotdotdot 多行出现点点点的解决方法 viewjs 查看图片的插件，功能强大 video.js 功能非常强大的视频音频播放库，可以自定义皮肤 收集汇总 前端收集 前端开发相关的优秀网站、博客、以及活跃开发者 前端技能汇总 前端技能汇总，包含前端知识架构，书籍推荐 Front-end-tutorial 最全的资源教程-前端涉及的所有知识体系 Front-end-Interview-questions 史上最全前端开发面试问题及答案 样式 Semantic-UI 让你使用任何HTML标签 来表现UI控件。这是一款语义化设计的前端框架，为攻城师而制作的可复用的开源前端框架 animate.css 动画样式 其他 机器学习 资料很全","tags":[{"name":"资源","slug":"资源","permalink":"http://www.leozeda.com/tags/资源/"}]},{"title":"HTML DOM","date":"2016-12-28T14:15:45.000Z","path":"2016/12/28/HTML-DOM/","text":"简介什么是DOM？DOM是W3C(万维网联盟)的标准，它定义了访问HTML和xml文档的标准： DOM(文档对象模型)是中立于平台和语言 接口，它允许程序和脚步动态访问和更新 文档的内容、结构和样式。 HTML DOM 提供了访问和操作HTML文档的接口和方法，或者说，HTML DOM 是关于如何获取、修改、添加或删除HTML元素的标准。 DOM节点根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树： image 常用方法getElementByIdgetElementById() 方法返回带有指定 ID 的元素：document.getElementById(&quot;intro&quot;); getElementsByTagNamegetElementsByTagName() 返回带有指定标签名的所有元素,下面的例子返回包含文档中所有 元素的列表：document.getElementsByTagName(&quot;p&quot;); getElementsByClassName如果您希望查找带有相同类名的所有 HTML 元素，请使用这个方法：document.getElementsByClassName(&quot;intro&quot;);注释：getElementsByClassName() 在 Internet Explorer 5,6,7,8 中无效。如果要获取2个以上classname，可传入多个classname，每个用空格相隔。 querySelector通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。document.querySelector(&quot;.test&quot;)兼容性问题：querySelector在ie8以下的浏览器不支持 querySelectorAllquerySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，返回的是一个非即时的NodeList。document.querySelectorAll(&quot;#test,.test&quot;)兼容性问题：querySelectorAll在ie8以下的浏览器不支持 createElementcreateElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签:var para=document.createElement(&quot;p&quot;);使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。 createTextNode创建文本节点:var node=document.createTextNode(&quot;This is new.&quot;);createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中。 cloneChildcloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下:123var parent = document.getElementById(&quot;parentElement&quot;);var parent2 = parent.cloneNode(true);// 传入trueparent2.id = &quot;parent2&quot;; appendChild追加到已有的元素上(末尾):123var para = document.createElement(&quot;p&quot;);var element = document.getElementById(&quot;div1&quot;);element.appendChild(para); insertBefore在某个元素前插入新元素1234var para = document.createElement(&quot;p&quot;);var element = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);element.insertBefore(para,child); parentNode.insertBefore(newNode,refNode)parentNode表示新节点被添加后的父节点newNode表示要添加的节点refNode表示参照节点，新节点会添加到这个节点之前 removeChild删除已有的 HTML 元素123var parent = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.removeChild(child); 找到您需要删除的子元素，然后使用 parentNode 属性来查找其父元素：12var child = document.getElementById(&quot;p1&quot;);child.parentNode.removeChild(child); replaceChild替换 HTML 元素1234var para = document.createElement(&quot;p&quot;);var element = document.getElementById(&quot;div1&quot;);var child = document.getElementById(&quot;p1&quot;);parent.replaceChild(para,child); parent.replaceNode(newChild,oldChild);newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置oldChild是被替换的节点 setAttributesetAttribute根据名称和值修改元素的特性:element.setAttribute(name, value);其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。如果元素本身包含指定的特性名为属性，则可以直接访问属性进行赋值，比如下面两条代码是等价的：12element.setAttribute(&quot;id&quot;,&quot;test&quot;);element.id = &quot;test&quot;; getAttributegetAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串:var value = element.getAttribute(&quot;id&quot;); getBoundingClientRectgetBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置:var clientRect = element.getBoundingClientRect();clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。具体参考MDN 属性innerHTMLinnerHTML 属性可用于获取或改变任意 HTML 元素，包括 和 ：12var txt=document.getElementById(&quot;intro&quot;).innerHTML;document.write(txt); nodeNamenodeName 属性规定节点的名称: nodeName 是只读的 元素节点的 nodeName 与标签名相同 属性节点的 nodeName 与属性名相同 文本节点的 nodeName 始终是 #text 文档节点的 nodeName 始终是 #document 注释：nodeName 始终包含 HTML 元素的大写字母标签名。 nodeValuenodeValue 属性规定节点的值。 元素节点的 nodeValue 是 undefined 或 null 文本节点的 nodeValue 是文本本身 属性节点的 nodeValue 是属性值 nodeTypenodeType 属性返回节点的类型。nodeType 是只读的, 比较重要的节点类型有： 元素类型 nodeType 元素 1 属性 2 文本 3 注释 8 文档 9 style通过 HTML DOM，您能够访问或修改 HTML 元素的样式对象:document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;; DOM 导航HTML DOM 节点列表getElementsByTagName() 方法返回节点列表。节点列表是一个节点数组，可以通过下标号访问这些节点。如需访问第二个 ，您可以这么写：12var x = document.getElementsByTagName(&quot;p&quot;);y = x[1]; HTML DOM 节点列表长度length 属性定义节点列表中节点的数量:123456x = document.getElementsByTagName(&quot;p&quot;);for (i=0;i&lt;x.length;i++)&#123; document.write(x[i].innerHTML); document.write(&quot;&lt;br /&gt;&quot;);&#125; 导航节点关系您能够使用三个节点属性：parentNode、firstChild 以及 lastChild ，在文档结构中进行导航 childNodes获取子节点：12var txt = document.getElementById(&quot;intro&quot;).childNodes[0].nodeValue;document.write(txt); 节点关系型API在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。 父关系型apiparentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null 兄弟关系型apipreviousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。 子关系型apichildNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。firstNode：第一个子节点lastNode：最后一个子节点hasChildNodes方法：可以用来判断是否包含子节点。 参考Javascript操作DOM常用API总结W3C HTML DOMMDN","tags":[{"name":"API","slug":"API","permalink":"http://www.leozeda.com/tags/API/"},{"name":"DOM","slug":"DOM","permalink":"http://www.leozeda.com/tags/DOM/"}]},{"title":"Hexo + Github Pages建博客","date":"2016-12-26T13:35:49.000Z","path":"2016/12/26/Hexo+GithubPages博客/","text":"前言作为一个有理想的程序员都希望自己弄一个属于自己的博客，当然我也不例外哈～平时查找相关资料或解决问题的时候就看到各种牛人们的博客，自己也一直想弄，但都没有太多时间去弄（借口）。一开始想在阿里云上弄个自己的网站然后写博客的，于是申请了两年免费的虚拟机，申请后闲置了半年才去折腾。虚拟机毕竟是虚拟机，它不支持ssh登录，不能自己安装软件，只是支持php、HTML、WAP，php、wap都不太懂。云服务器又不舍得买，也就只好安装wordpress来搭建博客，安装完选好主题之后，发现wordpress不太好用，感觉条条框框的较多，也就又搁置了一段时间。最后，在网上看到可以用hexo+githubpages搭建，也就又开始折腾了。hexo+githubpages比较好的地方： 根据Markdown文件直接生成静态的html 主题可以自己选择，并可以直接修改主题代码 完全免费 安装及基本用法hexo官网教程（英文）讲解都很详细的，按照文档一步步来都可以完成，网上搜到的教程很多很杂，有些教程可能是旧版本的，所以最后还是查看官网的教程，比较新，免得自己踩坑。安装依赖： Node.js Git 安装hexo：1$ npm install -g hexo-cli 安装完之后可以敲下面的命令查看hexo的用法，以及验证是否安装成功：$ hexo -h或--help 新建博客执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。若floder不存在会自动创建。$ hexo init &lt;folder&gt;新建文章新建一个题目为title的文章，新建的文件路径在source/_posts，文件名为title.md$ hexo new &lt;title&gt;启用本地服务运行下面的命令， 就可以在 localhost:4000/ 查看你的博客。$ hexo server（或 s） Hexo主题hexo默认的是landscape主题, 可以自己安装其他主题。在主题官网上个人比较喜欢的主题是indigo,这个主题的安装配置教程还是比较完善的。上了船之后，后来发现还有一些很不错的主题： material NexT 这两个教程就更完善了，不过这个还是看个人的喜好哈～ 官网的主题介绍相对比较简单，不过也说明了一些关键点，如： 修改主题只需修改_config.xml内的theme即可切换，前提是在themes文件夹内有这个主题 一个主题的文件结构为： _config.yml， 主题内的配置文件 languages， 一些国际化的配置 layout，主题的模板， 自己定制可以修改这里的模板 scripts， 第三方库脚本 source，样式，图片等 详细的安装过程，可以参考所下载主题的安装教程，如本站的indigo。需要注意的是该主题要求Node 版本为 6.x 以上，要不然会导致一些插件编译或部署错误。 Github Pages部署发布github pages是一个托管静态站点的服务，旨在能够直接从github仓库里托管个人、组织或项目页面。新建github page可以参考官网教程。如果有个人域名的可参考如何将github pages绑定到个人域名, 绑定后访问你的域名就可以直接访问到github pages，瞬间变得高大上。 生成静态文件$ hexo generate(或g)将md文件编译成静态网页到pulic目录下。1PS： public 目录下的style.css需要删除后，在生成，否则不会覆盖，不知道是否是bug 部署到git 官网教程安装 hexo-deployer-git$ npm install hexo-deployer-git --save修改配置文件_config.xml12345deploy: type: git repo: &lt;repository url&gt; branch: [branch] message: [message] (commit msg) 1PS： 一些非hexo的文件也可以放在public目录下，如CNAME，README.md等，放在其他地方不能部署到github 传送门 haroopad Markdown的编辑软件 Markdown语法及haroopad软件安装 hexo 插件","tags":[{"name":"hexo","slug":"hexo","permalink":"http://www.leozeda.com/tags/hexo/"},{"name":"教程","slug":"教程","permalink":"http://www.leozeda.com/tags/教程/"}]}]