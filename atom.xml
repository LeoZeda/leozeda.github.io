<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>You know nothing!</title>
  <subtitle>Do what you want~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.leozeda.com/"/>
  <updated>2017-01-04T02:45:57.892Z</updated>
  <id>http://www.leozeda.com/</id>
  
  <author>
    <name>Leo</name>
    <email>420212713@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue学习笔记</title>
    <link href="http://www.leozeda.com/2017/01/03/learning-vue/"/>
    <id>http://www.leozeda.com/2017/01/03/learning-vue/</id>
    <published>2017-01-03T15:53:19.000Z</published>
    <updated>2017-01-04T02:45:57.892Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>　　Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue完全有能力驱动采用单文件组件和Vue生态系统支持的库开发的复杂单页应用。<br>　　Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。<br>　　组件思想：将界面元素抽象为一个独立可复用的小组件，父组件包含若干个子组件，用这些组件构建大型的应用，因此任何一个应用界面都可以抽象为组件树。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/components.png" alt="组件思想" title="">
                </div>
                <div class="image-caption">组件思想</div>
            </figure><br>　　每个Vue实例在被创建之前都要经过一系列的初始化过程，例如，实例需要配置数据观测、编译模版、挂载实例到DOM、数据变化时更新DOM等，在实例的生命周期的不同阶段会调用不同的回调函数，用户可以在这些回调函数中定义自己的程序处理逻辑。<br>　　生命周期图示：<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/lifecycle.png" alt="生命周期" title="">
                </div>
                <div class="image-caption">生命周期</div>
            </figure></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>直接下载</strong><br>直接下载并在html中用script应用，Vue会被注册为一个全局变量。<br><a href="http://vuejs.org/js/vue.js" target="_blank" rel="external">开发版本</a> 包含了完整的警告和调试模式<br><a href="http://vuejs.org/js/vue.min.js" target="_blank" rel="external">生成版本</a> 删除警告</p>
<p><strong>NPM</strong><br>通过npm安装最新稳定版本<br><code>$ npm install vue</code></p>
<p><strong>命令行工具</strong><br>vue.js提供官方的命令行工具，可以快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程。只需几分钟即可创建并启动一个带热重载、保存时静态检查以及可用于生产环境的构建配置的项目。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"># 全局安装 vue-cli</div><div class="line">$ npm install -g vue-cli</div><div class="line"># 创建一个基于 webpack 模板的新项目</div><div class="line">$ vue init webpack my-project</div><div class="line"># 安装依赖，走你</div><div class="line">$ cd my-project</div><div class="line">$ npm install</div><div class="line">$ npm run dev</div><div class="line"></div><div class="line"># 其他命令</div><div class="line"># 可以查看官方提供的模版， 如webpack-simple、bowserify、week等</div><div class="line">$ vue list</div></pre></td></tr></table></figure></p>
<p>有前端基础的推荐使用命令行工具，它能够方便初学者快速构建各种框架工程，免去自己去查找资料的麻烦</p>
<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>数据绑定最常见的形式就是使用 “Mustache” 语法（双大括号）的文本插值：<br><code>&lt;span&gt;Message: { {msg}}&lt;/span&gt;</code></p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>计算属性是基于它的依赖缓存。计算属性只有在它的相关依赖发生改变时才会重新取值。这就意味着只要 message 没有发生改变，多次访问 reversedMessage 计算属性会立即返回之前的计算结果，而不必再次执行函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;example&quot;&gt;</div><div class="line">  &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">  &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">var vm = new Vue(&#123;</div><div class="line">  el: &apos;#example&apos;,</div><div class="line">  data: &#123;</div><div class="line">    message: &apos;Hello&apos;</div><div class="line">  &#125;,</div><div class="line">  computed: &#123;</div><div class="line">    // a computed getter</div><div class="line">    reversedMessage: function () &#123;</div><div class="line">      // `this` points to the vm instance</div><div class="line">      return this.message.split(&apos;&apos;).reverse().join(&apos;&apos;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="绑定属性"><a href="#绑定属性" class="headerlink" title="绑定属性"></a>绑定属性</h4><p>一些指令能接受一个“参数”，在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p><strong>Class与Style绑定</strong><br>数据绑定一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用v-bind 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 v-bind 用于 class 和 style 时， Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;div v-bind:class=&quot;&#123; active: isActive &#125;&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">//直接绑定数据里的一个对象</div><div class="line">&lt;div v-bind:class=&quot;classObject&quot;&gt;&lt;/div&gt;</div><div class="line">data: &#123;</div><div class="line">  classObject: &#123;</div><div class="line">    active: true,</div><div class="line">    &apos;text-danger&apos;: false</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//可以把一个数组传给 v-bind:class</div><div class="line">&lt;div v-bind:class=&quot;[activeClass, errorClass]&quot;&gt;</div><div class="line"></div><div class="line">//用在组件上</div><div class="line">//当你在一个定制的组件上用到 class 属性的时候，这些类将被添加到根元素上面，这个元素上已经存在的类不会被覆盖</div><div class="line">Vue.component(&apos;my-component&apos;, &#123;</div><div class="line">  template: &apos;&lt;p class=&quot;foo bar&quot;&gt;Hi&lt;/p&gt;&apos;</div><div class="line">&#125;)</div><div class="line">&lt;my-component class=&quot;baz boo&quot;&gt;&lt;/my-component&gt;</div><div class="line">//HTML 最终将被渲染成为:</div><div class="line">&lt;p class=&quot;foo bar baz boo&quot;&gt;Hi&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p>v-bind:style 的对象语法十分直观——看着非常像 CSS ，其实它是一个 JavaScript 对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">//CSS 属性名可以用驼峰式（camelCase）或短横分隔命名（kebab-case）：</div><div class="line">&lt;div v-bind:style=&quot;&#123; color: activeColor, fontSize: fontSize + &apos;px&apos; &#125;&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">//直接绑定到一个样式对象通常更好，让模板更清晰</div><div class="line">&lt;div v-bind:style=&quot;styleObject&quot;&gt;&lt;/div&gt;</div><div class="line">data: &#123;</div><div class="line">  styleObject: &#123;</div><div class="line">    color: &apos;red&apos;,</div><div class="line">    fontSize: &apos;13px&apos;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//v-bind:style 的数组语法可以将多个样式对象应用到一个元素上</div><div class="line">&lt;div v-bind:style=&quot;[baseStyles, overridingStyles]&quot;&gt;</div><div class="line"></div><div class="line">//当 v-bind:style 使用需要特定前缀的 CSS 属性时，如 transform ，Vue.js 会自动侦测并添加相应的前缀</div></pre></td></tr></table></figure></p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>单个语句<br><code>&lt;h1 v-if=&quot;ok&quot;&gt;Yes&lt;/h1&gt;</code><br>多条语句时，我们可以把一个 <code>&lt;template&gt;</code> 元素当做包装元素，并在上面使用 v-if，最终的渲染结果不会包含它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;template v-if=&quot;ok&quot;&gt;</div><div class="line">  &lt;h1&gt;Title&lt;/h1&gt;</div><div class="line">  &lt;p&gt;Paragraph 1&lt;/p&gt;</div><div class="line">  &lt;p&gt;Paragraph 2&lt;/p&gt;</div><div class="line">&lt;/template&gt;</div></pre></td></tr></table></figure>
<p>if-else</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div v-if=&quot;type === &apos;A&apos;&quot;&gt;A&lt;/div&gt;</div><div class="line">&lt;div v-else-if=&quot;type === &apos;B&apos;&quot;&gt;B&lt;/div&gt;</div><div class="line">&lt;div v-else&gt;C&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>另一个根据条件展示元素的选项是 v-show 指令。不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display 。注意 v-show 不支持 <code>&lt;template&gt;</code> 语法。<br><code>&lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;</code></p>
<blockquote>
<p>v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。</p>
</blockquote>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以 item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">  &lt;template v-for=&quot;item in items&quot;&gt;</div><div class="line">    &lt;li&gt;&#123;&#123; item.msg &#125;&#125;&lt;/li&gt;</div><div class="line">    &lt;li class=&quot;divider&quot;&gt;&lt;/li&gt;</div><div class="line">  &lt;/template&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<p>可以用 v-for 通过一个对象的属性来迭代<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;repeat-object&quot; class=&quot;demo&quot;&gt;</div><div class="line">  &lt;li v-for=&quot;value in object&quot;&gt;</div><div class="line">    &#123;&#123; value &#125;&#125;</div><div class="line">  &lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">或</div><div class="line">&lt;div v-for=&quot;(value, key, index) in object&quot;&gt;</div><div class="line">  &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>v-for 也可以取整数。在这种情况下，它将重复多次模板:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &lt;span v-for=&quot;n in 10&quot;&gt;&#123;&#123; n &#125;&#125;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：<br><code>&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt;</code><br>组件中使用v-for：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;my-component</div><div class="line">  v-for=&quot;(item, index) in items&quot;</div><div class="line">  v-bind:item=&quot;item&quot;</div><div class="line">  v-bind:index=&quot;index&quot;&gt;</div><div class="line">&lt;/my-component&gt;</div></pre></td></tr></table></figure></p>
<h4 id="监听事件"><a href="#监听事件" class="headerlink" title="监听事件"></a>监听事件</h4><p>v-on 指令，它用于监听 DOM 事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 完整语法 --&gt;</div><div class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 缩写 --&gt;</div><div class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</div></pre></td></tr></table></figure></p>
<p>监听事件可以用修饰符指定应该以特殊方式绑定。例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 event.preventDefault()：<br><code>&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</code><br><strong>其他修饰符：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">.stop</div><div class="line">.prevent</div><div class="line">.capture</div><div class="line">.self</div><div class="line">.once</div><div class="line">&lt;!-- 阻止单击事件冒泡 --&gt;</div><div class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 提交事件不再重载页面 --&gt;</div><div class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</div><div class="line">&lt;!-- 修饰符可以串联  --&gt;</div><div class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</div><div class="line">&lt;!-- 只有修饰符 --&gt;</div><div class="line">&lt;form v-on:submit.prevent&gt;&lt;/form&gt;</div><div class="line">&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;</div><div class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;</div><div class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p><strong>按键修饰符</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.enter</div><div class="line">.tab</div><div class="line">.delete (捕获 “删除” 和 “退格” 键)</div><div class="line">.esc</div><div class="line">.space</div><div class="line">.up</div><div class="line">.down</div><div class="line">.left</div><div class="line">.right</div><div class="line">&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;</div><div class="line">&lt;input v-on:keyup.13=&quot;submit&quot;&gt;</div><div class="line">&lt;!-- 同上 --&gt;</div><div class="line">&lt;input v-on:keyup.enter=&quot;submit&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>可以用如下修饰符开启鼠标或键盘事件监听，使在按键按下时发生响应:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.ctrl</div><div class="line">.alt</div><div class="line">.shift</div><div class="line">.meta</div><div class="line">&lt;!-- Alt + C --&gt;</div><div class="line">&lt;input @keyup.alt.67=&quot;clear&quot;&gt;</div><div class="line">&lt;!-- Ctrl + Click --&gt;</div><div class="line">&lt;div @click.ctrl=&quot;doSomething&quot;&gt;Do something&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<h3 id="双向数据绑定"><a href="#双向数据绑定" class="headerlink" title="双向数据绑定"></a>双向数据绑定</h3><p>v-model 指令在表单控件元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。<br><strong>文本</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</div><div class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</div></pre></td></tr></table></figure></p>
<p><strong>单选</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;input type=&quot;radio&quot; id=&quot;one&quot; value=&quot;One&quot; v-model=&quot;picked&quot;&gt;</div><div class="line">&lt;label for=&quot;one&quot;&gt;One&lt;/label&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;input type=&quot;radio&quot; id=&quot;two&quot; value=&quot;Two&quot; v-model=&quot;picked&quot;&gt;</div><div class="line">&lt;label for=&quot;two&quot;&gt;Two&lt;/label&gt;</div><div class="line">&lt;br&gt;</div><div class="line">&lt;span&gt;Picked: &#123;&#123; picked &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p><strong>选择列表</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;select v-model=&quot;selected&quot;&gt;</div><div class="line">  &lt;option v-for=&quot;option in options&quot; v-bind:value=&quot;option.value&quot;&gt;</div><div class="line">    &#123;&#123; option.text &#125;&#125;</div><div class="line">  &lt;/option&gt;</div><div class="line">&lt;/select&gt;</div><div class="line">&lt;span&gt;Selected: &#123;&#123; selected &#125;&#125;&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p><strong>修饰符</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;!-- 在 &quot;change&quot; 而不是 &quot;input&quot; 事件中更新 --&gt;</div><div class="line">&lt;input v-model.lazy=&quot;msg&quot; &gt;</div><div class="line"></div><div class="line">//如果想自动将用户的输入值转为 Number 类型（如果原值的转换结果为 NaN 则返回原值）</div><div class="line">&lt;input v-model.number=&quot;age&quot; type=&quot;number&quot;&gt;</div><div class="line"></div><div class="line">//自动过滤用户输入的首尾空格</div><div class="line">&lt;input v-model.trim=&quot;msg&quot;&gt;</div></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>　　官网基础教程讲解比较详细，从介绍-&gt;安装-&gt;实际例子都比较容易懂，不知道是否因为该库是华人开发的原因文档也由华人编写？<br>　　通过这次的学习可以发现Vue吸取了AngularJS(双向数据绑定、模版、指令)和React（组件、父子组件单向数据流、虚拟DOM）的思想，并融合成一种更适合开发者开发的框架。另外，该框架提供了大量方便开发的方法，如修饰符、过滤器等，免去了查找库或插件的麻烦(如React需要安装各种工具)，可以说Vue是从开发者角度去考虑的框架，开发者使用起来变得更加顺心。正因如此，我也开始对Vue产生兴趣了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="external">Vue官网教程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;　　Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，
    
    </summary>
    
      <category term="Vue" scheme="http://www.leozeda.com/categories/Vue/"/>
    
    
      <category term="教程" scheme="http://www.leozeda.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Vue" scheme="http://www.leozeda.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>资源收集</title>
    <link href="http://www.leozeda.com/2017/01/01/resource-collection/"/>
    <id>http://www.leozeda.com/2017/01/01/resource-collection/</id>
    <published>2017-01-01T14:13:15.000Z</published>
    <updated>2017-01-01T14:20:00.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具库"><a href="#工具库" class="headerlink" title="工具库"></a>工具库</h2><ol>
<li><a href="http://alvarotrigo.com/fullPage/" target="_blank" rel="external">FullPage</a> 非常好用的全屏滑动库, 有挺多Example</li>
<li><a href="https://github.com/hexojs/hexo" target="_blank" rel="external">Hexo</a> Markdown生成静态页面，可做博客</li>
<li><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">hexo-theme-material</a> Material主题的样式，作者非常用心，挺好看的主题，教程完整</li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">hexo-theme-next</a> NexT主题样式，比较经典，教程齐全</li>
<li><a href="https://github.com/amfe/lib-flexible" target="_blank" rel="external">lib-flexible</a> 阿里移动端多分辨率的兼容方案(rem)</li>
<li><a href="https://github.com/GcsSloop/TinyPng" target="_blank" rel="external">TinyPng</a> 图片批量压缩脚本(Python)</li>
<li><a href="https://github.com/nolimits4web/Swiper" target="_blank" rel="external">Swiper</a> 针对移动端触摸屏的滑屏插件，兼容iOS，Android，WP8和桌面浏览器</li>
<li><a href="https://github.com/CreateJS/EaselJS" target="_blank" rel="external">CreateJs</a> H5制作动画的库</li>
<li><a href="https://github.com/CezaryDanielNowak/React-dotdotdot" target="_blank" rel="external">React-dotdotdot</a> 多行出现点点点的解决方法</li>
<li><a href="https://github.com/fengyuanchen/viewerjs" target="_blank" rel="external">viewjs</a> 查看图片的插件，功能强大</li>
<li><a href="https://github.com/videojs/video.js" target="_blank" rel="external">video.js</a> 功能非常强大的视频音频播放库，可以自定义皮肤</li>
</ol>
<h2 id="收集汇总"><a href="#收集汇总" class="headerlink" title="收集汇总"></a>收集汇总</h2><ol>
<li><a href="https://github.com/foru17/front-end-collect" target="_blank" rel="external">前端收集</a> 前端开发相关的优秀网站、博客、以及活跃开发者</li>
<li><a href="https://github.com/JacksonTian/fks" target="_blank" rel="external">前端技能汇总</a> 前端技能汇总，包含前端知识架构，书籍推荐</li>
<li><a href="https://github.com/windiest/Front-end-tutorial" target="_blank" rel="external">Front-end-tutorial </a> 最全的资源教程-前端涉及的所有知识体系</li>
<li><a href="https://github.com/hawx1993/Front-end-Interview-questions" target="_blank" rel="external">Front-end-Interview-questions</a> 史上最全前端开发面试问题及答案</li>
</ol>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><ol>
<li><a href="https://github.com/Semantic-Org/Semantic-UI" target="_blank" rel="external">Semantic-UI</a> 让你使用任何HTML标签 来表现UI控件。这是一款语义化设计的前端框架，为攻城师而制作的可复用的开源前端框架</li>
<li><a href="https://github.com/daneden/animate.css" target="_blank" rel="external">animate.css</a> 动画样式</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li><a href="https://github.com/ZuzooVn/machine-learning-for-software-engineers" target="_blank" rel="external">机器学习</a> 资料很全</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;工具库&quot;&gt;&lt;a href=&quot;#工具库&quot; class=&quot;headerlink&quot; title=&quot;工具库&quot;&gt;&lt;/a&gt;工具库&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://alvarotrigo.com/fullPage/&quot; target=&quot;_blank&quot; r
    
    </summary>
    
      <category term="资源" scheme="http://www.leozeda.com/categories/%E8%B5%84%E6%BA%90/"/>
    
    
      <category term="资源" scheme="http://www.leozeda.com/tags/%E8%B5%84%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>HTML DOM</title>
    <link href="http://www.leozeda.com/2016/12/28/HTML-DOM/"/>
    <id>http://www.leozeda.com/2016/12/28/HTML-DOM/</id>
    <published>2016-12-28T14:15:45.000Z</published>
    <updated>2016-12-28T14:46:53.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h4 id="什么是DOM？"><a href="#什么是DOM？" class="headerlink" title="什么是DOM？"></a>什么是DOM？</h4><p>DOM是W3C(万维网联盟)的标准，它定义了访问HTML和xml文档的标准：</p>
<blockquote>
<p>DOM(文档对象模型)是中立于平台和语言 接口，它允许程序和脚步动态访问和更新 文档的内容、结构和样式。</p>
</blockquote>
<p>HTML DOM 提供了访问和操作HTML文档的接口和方法，或者说，HTML DOM 是关于如何获取、修改、添加或删除HTML元素的标准。</p>
<h4 id="DOM节点"><a href="#DOM节点" class="headerlink" title="DOM节点"></a>DOM节点</h4><p>根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：</p>
<ul>
<li>整个文档是一个文档节点</li>
<li>每个 HTML 元素是元素节点</li>
<li>HTML 元素内的文本是文本节点</li>
<li>每个 HTML 属性是属性节点</li>
<li>注释是注释节点</li>
</ul>
<p>HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="/images/dom_tree.jpg" alt="image" title="">
                </div>
                <div class="image-caption">image</div>
            </figure>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h4 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById"></a>getElementById</h4><p>getElementById() 方法返回带有指定 ID 的元素：<br><code>document.getElementById(&quot;intro&quot;);</code></p>
<h4 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName"></a>getElementsByTagName</h4><p>getElementsByTagName() 返回带有指定标签名的所有元素,下面的例子返回包含文档中所有 </p><p> 元素的列表：<br><code>document.getElementsByTagName(&quot;p&quot;);</code></p>
<h4 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h4><p>如果您希望查找带有相同类名的所有 HTML 元素，请使用这个方法：<br><code>document.getElementsByClassName(&quot;intro&quot;);</code><br><strong>注释</strong>：getElementsByClassName() 在 Internet Explorer 5,6,7,8 中无效。如果要获取2个以上classname，可传入多个classname，每个用空格相隔。</p>
<h4 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector"></a>querySelector</h4><p>通过css选择器来查找元素，注意选择器要符合CSS选择器的规则。querySelector返回第一个匹配的元素，如果没有匹配的元素，则返回null。<br><code>document.querySelector(&quot;.test&quot;)</code><br><strong>兼容性问题</strong>：querySelector在ie8以下的浏览器不支持</p>
<h4 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll"></a>querySelectorAll</h4><p>querySelectorAll的不同之处在于它返回的是所有匹配的元素，而且可以匹配多个选择符，返回的是一个非即时的NodeList。<br><code>document.querySelectorAll(&quot;#test,.test&quot;)</code><br><strong>兼容性问题</strong>：querySelectorAll在ie8以下的浏览器不支持</p>
<h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h4><p>createElement通过传入指定的一个标签名来创建一个元素，如果传入的标签名是一个未知的，则会创建一个自定义的标签，注意：IE8以下浏览器不支持自定义标签:<br><code>var para=document.createElement(&quot;p&quot;);</code><br>使用createElement要注意：通过createElement创建的元素并不属于html文档，它只是创建出来，并未添加到html文档中，要调用appendChild或insertBefore等方法将其添加到HTML文档树中。</p>
<h4 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode"></a>createTextNode</h4><p>创建文本节点:<br><code>var node=document.createTextNode(&quot;This is new.&quot;);</code><br>createTextNode接收一个参数，这个参数就是文本节点中的文本，和createElement一样，创建后的文本节点也只是独立的一个节点，同样需要appendChild将其添加到HTML文档树中。</p>
<h4 id="cloneChild"><a href="#cloneChild" class="headerlink" title="cloneChild"></a>cloneChild</h4><p>cloneNode是用来返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，使用如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var parent = document.getElementById(&quot;parentElement&quot;);</div><div class="line">var parent2 = parent.cloneNode(true);// 传入true</div><div class="line">parent2.id = &quot;parent2&quot;;</div></pre></td></tr></table></figure></p>
<h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild"></a>appendChild</h4><p>追加到已有的元素上(末尾):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var para = document.createElement(&quot;p&quot;);</div><div class="line">var element = document.getElementById(&quot;div1&quot;);</div><div class="line">element.appendChild(para);</div></pre></td></tr></table></figure></p>
<h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore"></a>insertBefore</h4><p>在某个元素前插入新元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var para = document.createElement(&quot;p&quot;);</div><div class="line">var element = document.getElementById(&quot;div1&quot;);</div><div class="line">var child = document.getElementById(&quot;p1&quot;);</div><div class="line">element.insertBefore(para,child);</div></pre></td></tr></table></figure></p>
<p>parentNode.insertBefore(newNode,refNode)<br>parentNode表示新节点被添加后的父节点<br>newNode表示要添加的节点<br>refNode表示参照节点，新节点会添加到这个节点之前</p>
<h4 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild"></a>removeChild</h4><p>删除已有的 HTML 元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var parent = document.getElementById(&quot;div1&quot;);</div><div class="line">var child = document.getElementById(&quot;p1&quot;);</div><div class="line">parent.removeChild(child);</div></pre></td></tr></table></figure></p>
<p>找到您需要删除的子元素，然后使用 parentNode 属性来查找其父元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var child = document.getElementById(&quot;p1&quot;);</div><div class="line">child.parentNode.removeChild(child);</div></pre></td></tr></table></figure></p>
<h4 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild"></a>replaceChild</h4><p>替换 HTML 元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var para = document.createElement(&quot;p&quot;);</div><div class="line">var element = document.getElementById(&quot;div1&quot;);</div><div class="line">var child = document.getElementById(&quot;p1&quot;);</div><div class="line">parent.replaceChild(para,child);</div></pre></td></tr></table></figure></p>
<p>parent.replaceNode(newChild,oldChild);<br>newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置<br>oldChild是被替换的节点</p>
<h4 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute"></a>setAttribute</h4><p>setAttribute根据名称和值修改元素的特性:<br><code>element.setAttribute(name, value);</code><br>其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。<br>如果元素本身包含指定的特性名为属性，则可以直接访问属性进行赋值，比如下面两条代码是等价的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">element.setAttribute(&quot;id&quot;,&quot;test&quot;);</div><div class="line">element.id = &quot;test&quot;;</div></pre></td></tr></table></figure></p>
<h4 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute"></a>getAttribute</h4><p>getAttribute返回指定的特性名相应的特性值，如果不存在，则返回null或空字符串:<br><code>var value = element.getAttribute(&quot;id&quot;);</code></p>
<h4 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect"></a>getBoundingClientRect</h4><p>getBoundingClientRect用来返回元素的大小以及相对于浏览器可视窗口的位置:<br><code>var clientRect = element.getBoundingClientRect();</code><br>clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。具体参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">MDN</a></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h4 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h4><p>innerHTML 属性可用于获取或改变任意 HTML 元素，包括 <html> 和 <body>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var txt=document.getElementById(&quot;intro&quot;).innerHTML;</div><div class="line">document.write(txt);</div></pre></td></tr></table></figure></body></html></p>
<h4 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h4><p>nodeName 属性规定节点的名称:</p>
<ul>
<li>nodeName 是只读的</li>
<li>元素节点的 nodeName 与标签名相同</li>
<li>属性节点的 nodeName 与属性名相同</li>
<li>文本节点的 nodeName 始终是 #text</li>
<li>文档节点的 nodeName 始终是 #document</li>
</ul>
<p><strong>注释</strong>：nodeName 始终包含 HTML 元素的大写字母标签名。</p>
<h4 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h4><p>nodeValue 属性规定节点的值。</p>
<ul>
<li>元素节点的 nodeValue 是 undefined 或 null</li>
<li>文本节点的 nodeValue 是文本本身</li>
<li>属性节点的 nodeValue 是属性值</li>
</ul>
<h4 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType"></a>nodeType</h4><p>nodeType 属性返回节点的类型。nodeType 是只读的, 比较重要的节点类型有：</p>
<table>
<thead>
<tr>
<th style="text-align:left">元素类型</th>
<th style="text-align:center">nodeType</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">元素</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:left">属性</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:left">文本</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:left">注释</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:left">文档</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><p>通过 HTML DOM，您能够访问或修改 HTML 元素的样式对象:<br><code>document.getElementById(&quot;p2&quot;).style.color=&quot;blue&quot;;</code></p>
<h2 id="DOM-导航"><a href="#DOM-导航" class="headerlink" title="DOM 导航"></a>DOM 导航</h2><p><strong>HTML DOM 节点列表</strong><br>getElementsByTagName() 方法返回节点列表。节点列表是一个节点数组，可以通过下标号访问这些节点。如需访问第二个 </p><p>，您可以这么写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x = document.getElementsByTagName(&quot;p&quot;);</div><div class="line">y = x[1];</div></pre></td></tr></table></figure></p>
<p><strong>HTML DOM 节点列表长度</strong><br>length 属性定义节点列表中节点的数量:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">x = document.getElementsByTagName(&quot;p&quot;);</div><div class="line">for (i=0;i&lt;x.length;i++)</div><div class="line">&#123;</div><div class="line">    document.write(x[i].innerHTML);</div><div class="line">    document.write(&quot;&lt;br /&gt;&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>导航节点关系</strong><br>您能够使用三个节点属性：parentNode、firstChild 以及 lastChild ，在文档结构中进行导航</p>
<p><strong>childNodes</strong><br>获取子节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var txt = document.getElementById(&quot;intro&quot;).childNodes[0].nodeValue;</div><div class="line">document.write(txt);</div></pre></td></tr></table></figure></p>
<h2 id="节点关系型API"><a href="#节点关系型API" class="headerlink" title="节点关系型API"></a>节点关系型API</h2><p>在html文档中的每个节点之间的关系都可以看成是家谱关系，包含父子关系，兄弟关系等等，下面我们依次来看看每一种关系。</p>
<h4 id="父关系型api"><a href="#父关系型api" class="headerlink" title="父关系型api"></a>父关系型api</h4><p>parentNode：每个节点都有一个parentNode属性，它表示元素的父节点。Element的父节点可能是Element，Document或DocumentFragment。<br>parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null</p>
<h4 id="兄弟关系型api"><a href="#兄弟关系型api" class="headerlink" title="兄弟关系型api"></a>兄弟关系型api</h4><p>previousSibling：节点的前一个节点，如果该节点是第一个节点，则为null。注意有可能拿到的节点是文本节点或注释节点，与预期的不符，要进行处理一下。<br>previousElementSibling：返回前一个元素节点，前一个节点必须是Element，注意IE9以下浏览器不支持。<br>nextSibling：节点的后一个节点，如果该节点是最后一个节点，则为null。注意有可能拿到的节点是文本节点，与预期的不符，要进行处理一下。<br>nextElementSibling：返回后一个元素节点，后一个节点必须是Element，注意IE9以下浏览器不支持。</p>
<h4 id="子关系型api"><a href="#子关系型api" class="headerlink" title="子关系型api"></a>子关系型api</h4><p>childNodes：返回一个即时的NodeList，表示元素的子节点列表，子节点可能会包含文本节点，注释节点等。<br>children：一个即时的HTMLCollection，子节点都是Element，IE9以下浏览器不支持。<br>firstNode：第一个子节点<br>lastNode：最后一个子节点<br>hasChildNodes方法：可以用来判断是否包含子节点。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://web.jobbole.com/84364/" target="_blank" rel="external">Javascript操作DOM常用API总结</a><br><a href="http://www.w3school.com.cn/htmldom/" target="_blank" rel="external">W3C HTML DOM</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect" target="_blank" rel="external">MDN</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;h4 id=&quot;什么是DOM？&quot;&gt;&lt;a href=&quot;#什么是DOM？&quot; class=&quot;headerlink&quot; title=&quot;什么是DOM？&quot;&gt;&lt;/
    
    </summary>
    
      <category term="API" scheme="http://www.leozeda.com/categories/API/"/>
    
    
      <category term="API" scheme="http://www.leozeda.com/tags/API/"/>
    
      <category term="DOM" scheme="http://www.leozeda.com/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo + Github Pages建博客</title>
    <link href="http://www.leozeda.com/2016/12/26/Hexo+GithubPages%E5%8D%9A%E5%AE%A2/"/>
    <id>http://www.leozeda.com/2016/12/26/Hexo+GithubPages博客/</id>
    <published>2016-12-26T13:35:49.000Z</published>
    <updated>2016-12-28T14:47:33.801Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为一个有理想的程序员都希望自己弄一个属于自己的博客，当然我也不例外哈～平时查找相关资料或解决问题的时候就看到各种牛人们的博客，自己也一直想弄，但都没有太多时间去弄（借口）。<br>一开始想在阿里云上弄个自己的网站然后写博客的，于是申请了两年免费的虚拟机，申请后闲置了半年才去折腾。虚拟机毕竟是虚拟机，它不支持ssh登录，不能自己安装软件，只是支持php、HTML、WAP，php、wap都不太懂。云服务器又不舍得买，也就只好安装wordpress来搭建博客，安装完选好主题之后，发现wordpress不太好用，感觉条条框框的较多，也就又搁置了一段时间。最后，在网上看到可以用hexo+githubpages搭建，也就又开始折腾了。<br>hexo+githubpages比较好的地方：</p>
<ul>
<li>根据Markdown文件直接生成静态的html</li>
<li><a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>可以自己选择，并可以直接修改主题代码</li>
<li>完全免费</li>
</ul>
<h2 id="安装及基本用法"><a href="#安装及基本用法" class="headerlink" title="安装及基本用法"></a>安装及基本用法</h2><p>hexo<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">官网教程</a>（<a href="https://hexo.io/docs/" target="_blank" rel="external">英文</a>）讲解都很详细的，按照文档一步步来都可以完成，网上搜到的教程很多很杂，有些教程可能是旧版本的，所以最后还是查看官网的教程，比较新，免得自己踩坑。<br><strong>安装依赖</strong>：</p>
<ul>
<li><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a></li>
<li><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></li>
</ul>
<p><strong>安装hexo</strong>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<p>安装完之后可以敲下面的命令查看hexo的用法，以及验证是否安装成功：<br><code>$ hexo -h或--help</code></p>
<p><strong>新建博客</strong><br>执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。若floder不存在会自动创建。<br><code>$ hexo init &lt;folder&gt;</code><br><strong>新建文章</strong><br>新建一个题目为title的文章，新建的文件路径在source/_posts，文件名为title.md<br><code>$ hexo new &lt;title&gt;</code><br><strong>启用本地服务</strong><br>运行下面的命令， 就可以在 localhost:4000/ 查看你的博客。<br><code>$ hexo server（或 s）</code></p>
<h2 id="Hexo主题"><a href="#Hexo主题" class="headerlink" title="Hexo主题"></a>Hexo主题</h2><p>hexo默认的是landscape主题, 可以自己安装其他主题。在主题官网上个人比较喜欢的主题是<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="external">indigo</a>,这个主题的安装配置<a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="external">教程</a>还是比较完善的。<br>上了船之后，后来发现还有一些很不错的主题：</p>
<ul>
<li><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">material</a></li>
<li><a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="external">NexT</a></li>
</ul>
<p>这两个教程就更完善了，不过这个还是看个人的喜好哈～</p>
<p>官网的<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="external">主题介绍</a>相对比较简单，不过也说明了一些关键点，如：</p>
<ul>
<li>修改主题只需修改_config.xml内的theme即可切换，前提是在themes文件夹内有这个主题</li>
<li>一个主题的文件结构为：<ul>
<li>_config.yml， 主题内的配置文件</li>
<li>languages， 一些国际化的配置</li>
<li>layout，主题的模板， 自己定制可以修改这里的模板</li>
<li>scripts， 第三方库脚本</li>
<li>source，样式，图片等</li>
</ul>
</li>
</ul>
<p>详细的安装过程，可以参考所下载主题的安装教程，如本站的<a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="external">indigo</a>。需要注意的是该主题要求Node 版本为 6.x 以上，要不然会导致一些插件编译或部署错误。</p>
<h2 id="Github-Pages部署发布"><a href="#Github-Pages部署发布" class="headerlink" title="Github Pages部署发布"></a>Github Pages部署发布</h2><p><a href="https://pages.github.com" target="_blank" rel="external">github pages</a>是一个托管静态站点的服务，旨在能够直接从github仓库里托管个人、组织或项目页面。新建github page可以参考<a href="https://pages.github.com/" target="_blank" rel="external">官网教程</a>。<br>如果有个人域名的可参考如何将<a href="http://blog.csdn.net/lmj623565791/article/details/51319147" target="_blank" rel="external">github pages绑定到个人域名</a>, 绑定后访问你的域名就可以直接访问到github pages，瞬间变得高大上。</p>
<p><strong>生成静态文件</strong><br><code>$ hexo generate(或g)</code>将md文件编译成静态网页到pulic目录下。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS： public 目录下的style.css需要删除后，在生成，否则不会覆盖，不知道是否是bug</div></pre></td></tr></table></figure></p>
<p><strong>部署到git</strong>    <a href="https://hexo.io/zh-cn/docs/deployment.html#Git" target="_blank" rel="external">官网教程</a><br>安装 hexo-deployer-git<br><code>$ npm install hexo-deployer-git --save</code><br>修改配置文件_config.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: git</div><div class="line">  repo: &lt;repository url&gt;</div><div class="line">  branch: [branch]</div><div class="line">  message: [message] (commit msg)</div></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PS： 一些非hexo的文件也可以放在public目录下，如CNAME，README.md等，放在其他地方不能部署到github</div></pre></td></tr></table></figure>
<h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ul>
<li><a href="http://pad.haroopress.com/user.html" target="_blank" rel="external">haroopad</a> Markdown的编辑软件</li>
<li><a href="http://blog.csdn.net/tao_627/article/details/50625436" target="_blank" rel="external">Markdown语法及haroopad软件安装</a></li>
<li><a href="https://github.com/hexojs/hexo/wiki/Plugins" target="_blank" rel="external">hexo 插件</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;作为一个有理想的程序员都希望自己弄一个属于自己的博客，当然我也不例外哈～平时查找相关资料或解决问题的时候就看到各种牛人们的博客，自己也一直想
    
    </summary>
    
      <category term="教程" scheme="http://www.leozeda.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="hexo" scheme="http://www.leozeda.com/tags/hexo/"/>
    
      <category term="教程" scheme="http://www.leozeda.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
</feed>
